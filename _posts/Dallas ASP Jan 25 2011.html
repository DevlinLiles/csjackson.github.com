---
layout: post
title: GIT Commands
---
<div>
<p>
Dallas ASP.Net User Group Meeting 01/25/2011
<p>
Once again scrambling to get a seat on time, I sat down to my first ASP.Net meeting. After a few 
announcements, including one that a new version of Webmatrix, a hobbyist web development tool, is due 
for release, we began a conversation on patterns in software development. Had everyone brought their 
book? Read it? What? We discussed this back in the October meeting, or course. Looks like I'm playing 
some more catch-up.
<p>
What are "Patterns", anyhow? Patterns are systems that developers use over and over again, to achieve 
results. They are things programmers have all been doing since programming was something done with 
punch-cards, but giving them names gives us a common vocabulary so that we can talk to each other 
about them, and when they do or don't' fit a given project. They're jargon: simple linguistic handles on 
complex ideas specific to a given trade.
<p>
As we discussed some of them, I recognized some of them in work that our Adventure project had already 
implemented.  Clearly, this was why Tim was so keen that I see this particular talk. The hand-out that went 
along with the talk had 23, and we skimmed over 7 of them. Already, I saw the pattern "Strategy" <i>(a set of 
encapsulated algorithms that can be swapped to carry out specific behavior) </i> well at work in our command 
parser. Rather than one class that will handle any user's command and its behavior, we can define what a 
command should look like, and tell the program to search a common repository for which command is 
called. This makes extending our command lexicon as simple as writing a new class, and adding it to the 
enumeration.
<p>
The Strategy pattern teaches us to:<p>
<ul>
<il>
Identify the common and unique behaviors of given actions.</li>
<li>
Program to an interface, like one of those tool kits that all slot in a common power pack, so you only have 
to write the "power pack" or "handle" bits of the program once. This also makes the program's behavior 
more unified, flattening the user's learning curve, later.</li>
<li>
Favor composition over inheritance (For later: learn what the difference is.</li>
</ul><p>
We discussed the Observer pattern, which is so common that the .net framework already is built with 
event handling baked in. <p>

The Command pattern saw time in the spot light. If you encapsulate a request correctly, you can treat it 
like an object. For example, a universal remote doesn't need to know how to switch DVDs, it just needs to 
know how to pass the command to the player, secure in the knowledge that the player knows how to 
switch DVDs.<p><p>
I have to admit that I don't understand how the Façade pattern differs from command. Aren't they both 
about presenting a unified interface between different elements in a solution, so that you have only one 
format, and allow the specific sub-systems coded to deal with the differences work on them, while 
presenting a unified interface?
<p>
Several other patterns got mentioned, including "Antipatterns": patterns commonly used but 
counterproductive, such as spaghetti code, or Gold-Plating (Good enough is, by definition, good enough!). 
An antipattern is different from a common mistake or bad habit if it meets 2 criteria. It must first, initially 
appear helpful, and second, a better answer must already have been clearly delineated somewhere.
